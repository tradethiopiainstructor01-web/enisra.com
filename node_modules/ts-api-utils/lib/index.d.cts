import ts from 'typescript';

/**
 * Callback type used for {@link forEachComment}.
 * @category Callbacks
 */
type ForEachCommentCallback = (fullText: string, comment: ts.CommentRange) => void;
/**
 * Iterates over all comments owned by `node` or its children.
 * @category Nodes - Other Utilities
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * forEachComment(node, (fullText, comment) => {
 *    console.log(`Found comment at position ${comment.pos}: '${fullText}'.`);
 * });
 * ```
 */
declare function forEachComment(node: ts.Node, callback: ForEachCommentCallback, sourceFile?: ts.SourceFile): void;

/**
 * An option that can be tested with {@link isCompilerOptionEnabled}.
 * @category Compiler Options
 */
type BooleanCompilerOptions = keyof {
    [K in keyof ts.CompilerOptions as NonNullable<ts.CompilerOptions[K]> extends boolean ? K : never]: unknown;
};
/**
 * Checks if a given compiler option is enabled.
 * It handles dependencies of options, e.g. `declaration` is implicitly enabled by `composite` or `strictNullChecks` is enabled by `strict`.
 * However, it does not check dependencies that are already checked and reported as errors, e.g. `checkJs` without `allowJs`.
 * This function only handles boolean flags.
 * @category Compiler Options
 * @example
 * ```ts
 * const options = {
 * 	allowJs: true,
 * };
 *
 * isCompilerOptionEnabled(options, "allowJs"); // true
 * isCompilerOptionEnabled(options, "allowSyntheticDefaultImports"); // false
 * ```
 */
declare function isCompilerOptionEnabled(options: ts.CompilerOptions, option: BooleanCompilerOptions): boolean;
/**
 * An option that can be tested with {@link isStrictCompilerOptionEnabled}.
 * @category Compiler Options
 */
type StrictCompilerOption = "alwaysStrict" | "noImplicitAny" | "noImplicitThis" | "strictBindCallApply" | "strictFunctionTypes" | "strictNullChecks" | "strictPropertyInitialization";
/**
 * Checks if a given compiler option is enabled, accounting for whether all flags
 * (except `strictPropertyInitialization`) have been enabled by `strict: true`.
 * @category Compiler Options
 * @example
 * ```ts
 * const optionsLenient = {
 * 	noImplicitAny: true,
 * };
 *
 * isStrictCompilerOptionEnabled(optionsLenient, "noImplicitAny"); // true
 * isStrictCompilerOptionEnabled(optionsLenient, "noImplicitThis"); // false
 * ```
 * @example
 * ```ts
 * const optionsStrict = {
 * 	noImplicitThis: false,
 * 	strict: true,
 * };
 *
 * isStrictCompilerOptionEnabled(optionsStrict, "noImplicitAny"); // true
 * isStrictCompilerOptionEnabled(optionsStrict, "noImplicitThis"); // false
 * ```
 */
declare function isStrictCompilerOptionEnabled(options: ts.CompilerOptions, option: StrictCompilerOption): boolean;

/**
 * Test if the given node has the given `ModifierFlags` set.
 * @category Nodes - Flag Utilities
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isModifierFlagSet(node, ts.ModifierFlags.Abstract)) {
 *   // ...
 * }
 * ```
 */
declare function isModifierFlagSet(node: ts.Declaration, flag: ts.ModifierFlags): boolean;
/**
 * Test if the given node has the given `NodeFlags` set.
 * @category Nodes - Flag Utilities
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNodeFlagSet(node, ts.NodeFlags.AwaitContext)) {
 *   // ...
 * }
 * ```
 */
declare const isNodeFlagSet: (node: ts.Node, flag: ts.NodeFlags) => boolean;
/**
 * Test if the given node has the given `ObjectFlags` set.
 * @category Nodes - Flag Utilities
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isObjectFlagSet(node, ts.ObjectFlags.Anonymous)) {
 *   // ...
 * }
 * ```
 */
declare function isObjectFlagSet(objectType: ts.ObjectType, flag: ts.ObjectFlags): boolean;
/**
 * Test if the given node has the given `SymbolFlags` set.
 * @category Nodes - Flag Utilities
 * @example
 * ```ts
 * declare const symbol: ts.Symbol;
 *
 * if (isSymbolFlagSet(symbol, ts.SymbolFlags.Accessor)) {
 *   // ...
 * }
 * ```
 */
declare const isSymbolFlagSet: (symbol: ts.Symbol, flag: ts.SymbolFlags) => boolean;
/**
 * Test if the given symbol's links has the given `CheckFlags` set.
 * @internal
 */
declare function isTransientSymbolLinksFlagSet(links: ts.TransientSymbolLinks, flag: ts.CheckFlags): boolean;
/**
 * Test if the given node has the given `TypeFlags` set.
 * @category Nodes - Flag Utilities
 * @example
 * ```ts
 * declare const type: ts.Type;
 *
 * if (isTypeFlagSet(type, ts.TypeFlags.Any)) {
 *   // ...
 * }
 * ```
 */
declare const isTypeFlagSet: (type: ts.Type, flag: ts.TypeFlags) => boolean;

/**
 * Test if the given iterable includes a modifier of any of the given kinds.
 * @category Modifier Utilities
 * @example
 * ```ts
 * declare const modifiers: ts.Modifier[];
 *
 * includesModifier(modifiers, ts.SyntaxKind.AbstractKeyword);
 * ```
 */
declare function includesModifier(modifiers: Iterable<ts.ModifierLike> | undefined, ...kinds: ts.ModifierSyntaxKind[]): boolean;

/**
 * What operations(s), if any, an expression applies.
 */
declare enum AccessKind {
    None = 0,
    Read = 1,
    Write = 2,
    Delete = 4,
    ReadWrite = 3
}
/**
 * Determines which operation(s), if any, an expression applies.
 * @example
 * ```ts
 * declare const node: ts.Expression;
 *
 * if (getAccessKind(node).Write & AccessKind.Write) !== 0) {
 *   // this is a reassignment (write)
 * }
 * ```
 */
declare function getAccessKind(node: ts.Expression): AccessKind;

/**
 * An `AssertionExpression` that is declared as const.
 * @category Node Types
 */
type ConstAssertionExpression = {
    type: ts.TypeReferenceNode;
    typeName: ConstAssertionIdentifier;
} & ts.AssertionExpression;
/**
 * An `Identifier` with an `escapedText` value of `"const"`.
 * @category Node Types
 */
type ConstAssertionIdentifier = {
    escapedText: "const" & ts.__String;
} & ts.Identifier;
/**
 * Test if a node is a {@link ConstAssertionExpression}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isConstAssertionExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link ConstAssertionExpression}.
 */
declare function isConstAssertionExpression(node: ts.AssertionExpression): node is ConstAssertionExpression;
/**
 * Test if a node is an `IterationStatement`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isIterationStatement(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `IterationStatement`.
 */
declare function isIterationStatement(node: ts.Node): node is ts.IterationStatement;
/**
 * Test if a node is a `JSDocNamespaceDeclaration`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isJSDocNamespaceDeclaration(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `JSDocNamespaceDeclaration`.
 */
declare function isJSDocNamespaceDeclaration(node: ts.Node): node is ts.JSDocNamespaceDeclaration;
/**
 * Test if a node is a `JsxTagNamePropertyAccess`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isJsxTagNamePropertyAccess(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `JsxTagNamePropertyAccess`.
 */
declare function isJsxTagNamePropertyAccess(node: ts.Node): node is ts.JsxTagNamePropertyAccess;
/**
 * a `NamedDeclaration` that definitely has a name.
 * @category Node Types
 */
interface NamedDeclarationWithName extends ts.NamedDeclaration {
    name: ts.DeclarationName;
}
/**
 * Test if a node is a {@link NamedDeclarationWithName}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNamedDeclarationWithName(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link NamedDeclarationWithName}.
 */
declare function isNamedDeclarationWithName(node: ts.Declaration): node is NamedDeclarationWithName;
/**
 * Test if a node is a `NamespaceDeclaration`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNamespaceDeclaration(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `NamespaceDeclaration`.
 */
declare function isNamespaceDeclaration(node: ts.Node): node is ts.NamespaceDeclaration;
/**
 * A number or string-like literal.
 * @category Node Types
 */
type NumericOrStringLikeLiteral = ts.NumericLiteral | ts.StringLiteralLike;
/**
 * Test if a node is a {@link NumericOrStringLikeLiteral}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isNumericOrStringLikeLiteral(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a {@link NumericOrStringLikeLiteral}.
 */
declare function isNumericOrStringLikeLiteral(node: ts.Node): node is NumericOrStringLikeLiteral;
/**
 * Test if a node is a `PropertyAccessEntityNameExpression`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isPropertyAccessEntityNameExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `PropertyAccessEntityNameExpression`.
 */
declare function isPropertyAccessEntityNameExpression(node: ts.Node): node is ts.PropertyAccessEntityNameExpression;
/**
 * Test if a node is a `SuperElementAccessExpression`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isSuperElementAccessExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `SuperElementAccessExpression`.
 */
declare function isSuperElementAccessExpression(node: ts.Node): node is ts.SuperElementAccessExpression;
/**
 * Test if a node is a `SuperPropertyAccessExpression`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isSuperPropertyAccessExpression(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be a `SuperPropertyAccessExpression`.
 */
declare function isSuperPropertyAccessExpression(node: ts.Node): node is ts.SuperPropertyAccessExpression;

/**
 * A node that represents the any keyword.
 * @category Node Types
 */
type AnyKeyword = ts.KeywordToken<ts.SyntaxKind.AnyKeyword>;
/**
 * A node that represents the bigint keyword.
 * @category Node Types
 */
type BigIntKeyword = ts.KeywordToken<ts.SyntaxKind.BigIntKeyword>;
/**
 * A node that represents the boolean keyword.
 * @category Node Types
 */
type BooleanKeyword = ts.KeywordToken<ts.SyntaxKind.BooleanKeyword>;
/**
 * A node that represents the false keyword.
 * @category Node Types
 */
type FalseKeyword = ts.KeywordToken<ts.SyntaxKind.FalseKeyword>;
/**
 * A node that represents the import keyword.
 * @category Node Types
 */
type ImportKeyword = ts.KeywordToken<ts.SyntaxKind.ImportKeyword>;
/**
 * A node that represents the never keyword.
 * @category Node Types
 */
type NeverKeyword = ts.KeywordToken<ts.SyntaxKind.NeverKeyword>;
/**
 * A node that represents the null keyword.
 * @category Node Types
 */
type NullKeyword = ts.KeywordToken<ts.SyntaxKind.NullKeyword>;
/**
 * A node that represents the number keyword.
 * @category Node Types
 */
type NumberKeyword = ts.KeywordToken<ts.SyntaxKind.NumberKeyword>;
/**
 * A node that represents the object keyword.
 * @category Node Types
 */
type ObjectKeyword = ts.KeywordToken<ts.SyntaxKind.ObjectKeyword>;
/**
 * A node that represents the string keyword.
 * @category Node Types
 */
type StringKeyword = ts.KeywordToken<ts.SyntaxKind.StringKeyword>;
/**
 * A node that represents the super keyword.
 * @category Node Types
 */
type SuperKeyword = ts.KeywordToken<ts.SyntaxKind.SuperKeyword>;
/**
 * A node that represents the symbol keyword.
 * @category Node Types
 */
type SymbolKeyword = ts.KeywordToken<ts.SyntaxKind.SymbolKeyword>;
/**
 * A node that represents the this keyword.
 * @category Node Types
 */
type ThisKeyword = ts.KeywordToken<ts.SyntaxKind.ThisKeyword>;
/**
 * A node that represents the true keyword.
 * @category Node Types
 */
type TrueKeyword = ts.KeywordToken<ts.SyntaxKind.TrueKeyword>;
/**
 * A node that represents the undefined keyword.
 * @category Node Types
 */
type UndefinedKeyword = ts.KeywordToken<ts.SyntaxKind.UndefinedKeyword>;
/**
 * A node that represents the unknown keyword.
 * @category Node Types
 */
type UnknownKeyword = ts.KeywordToken<ts.SyntaxKind.UnknownKeyword>;
/**
 * A node that represents the void keyword.
 * @category Node Types
 */
type VoidKeyword = ts.KeywordToken<ts.SyntaxKind.VoidKeyword>;
/**
 * Test if a node is an `AbstractKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAbstractKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AbstractKeyword`.
 */
declare function isAbstractKeyword(node: ts.Node): node is ts.AbstractKeyword;
/**
 * Test if a node is an `AccessorKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAccessorKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AccessorKeyword`.
 */
declare function isAccessorKeyword(node: ts.Node): node is ts.AccessorKeyword;
/**
 * Test if a node is an {@link AnyKeyword}.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAnyKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an {@link AnyKeyword}.
 */
declare function isAnyKeyword(node: ts.Node): node is AnyKeyword;
/**
 * Test if a node is an `AssertKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAssertKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AssertKeyword`.
 */
declare function isAssertKeyword(node: ts.Node): node is ts.AssertKeyword;
/**
 * Test if a node is an `AssertsKeyword`.
 * @deprecated With TypeScript v5, in favor of typescript's `isAssertsKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAssertsKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AssertsKeyword`.
 */
declare function isAssertsKeyword(node: ts.Node): node is ts.AssertsKeyword;
/**
 * Test if a node is an `AsyncKeyword`.
 * @category Nodes - Type Guards
 * @example
 * ```ts
 * declare const node: ts.Node;
 *
 * if (isAsyncKeyword(node)) {
 *   // ...
 * }
 * ```
 * @returns Whether the given node appears to be an `AsyncKeyword`.
 */
declare function isAsyncKeyword(node: ts.Node): node is ts.AsyncKeyword;
/**
 * Test if a node is an `AwaitKeyword`.
 * @deprecated With TypeScript v5, in favor of typescript's `isAwaitKeyword`.
 * @categ